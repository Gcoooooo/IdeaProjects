package sortAlgorithms;

public class InsertionSortClass {
	
	public void insertionSort(int[] nums) {
		/*
		 * 1.
		 */
		for (int i = 1; i < nums.length; i++) { //每轮选出一个元素往前插入，从第二个元素开始选
			
			/*
			 * 方法一：遇到大的就交换
			 */
//			for (int j = i; j > 0 && nums[j - 1] > nums[j]; j--) { // 选出元素后，依次和之前的元素进行比较(nums[j - 1] > nums[j])，更小就往前挪
//				                                               // 直到num[i]>num[j]之后，由于条件不满足就会跳出循环，不再继续往前比较，故当数组部分有序时，比较次数和挪动次数都较少
//				                                               // 由于之前排好序的元素越来越多（j的初始值越来越大），比较次数逐渐递增，最多需要比较N^2/2次，最少N-1次（数组已完全有序）
//				                                               // 当相等时不会执行交换，故排序是稳定的
//				
//				int temp = nums[j];
//				nums[j] = nums[j - 1];
//				nums[j - 1] = temp;
//				
//				/*
//				 * 方法二：遇到大的先往后挪
//				 */
//				nums[j] = nums [j - 1];
//			}
			
			/*
			 * 方法二：遇到大的先往后挪
			 */
			int cur = nums[i];
			int j = 0;
			for (j = i - 1; j >= 0 && nums[j] > cur; j--) { // 选出元素后，固定该元素，依次和之前的元素进行比较，大的就往后挪，避免了交换带来的多次访问数组
				                                            // 直到num[i] > cur之后，由于条件不满足就会跳出循环，不再继续往前比较
				                                            // 由于之前排好序的元素越来越多（j的初始值越来越大），比较次数逐渐递增，最多需要比较N^2/2次，最少N-1次（数组已完全有序）
				                                            // 当相等时不会执行交换，故排序是稳定的
				
				nums[j + 1] = nums [j]; //大的元素往后放
			}
			
			nums[j + 1] = cur; //跳出循环时，j进行了自减，j需要指向最后一个往后挪的元素的位置，并将该位置的值换成cur
		}
	}

}
